% $Id: introduction.tex,v 1.8 2013/12/03 09:17:27 ccamacho Exp $
\section{Introduction}
\label{ref:introduction}

%The main purpose of Software Product Lines (in short, \SPLs) is to produce products
%while increasing productivity and shortening the time-to-market period. \SPLs\ depend
%on which software products are being produced and which of them are better for
%a specific criterion. When products are represented in a product line organization,
%several modeling approaches can be used to increase both quality and productivity.
%In most cases this is represented in the form of features, relationships and
%constraints. For instance, some of these approaches are FODA~\cite{kchnp90},
%RSEB~\cite{mj98} and PLUSS~\cite{k05,ebb06}.

During the last years, software product lines (in short, \SPLs) have become a widely adopted mechanism for efficient software development. The Carnegie Mellon Software Engineering Institute defines an \SPL\ as ``a set of software-intensive systems that share a common, managed set of features satisfying the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way''~\cite{mcg01}. Basically, the main goal of \SPLs\ is to increase the productivity for creating software products, which is achieved by selecting those software systems that are better for a specific criterion (e.g. a software system is less expensive than others, it requires less time to be processed, etc.). Currently, different approaches for representing the product line organization can be found in the literature, such as FODA~\cite{kchnp90},
RSEB~\cite{mj98} and PLUSS~\cite{k05,ebb06}.

Graphical approaches are commonly used to model \SPLs. Feature Oriented Domain Analysis~\cite{kchnp90} (in short, \FODA) is a well-known graphical approach for representing commonality and variability of systems. Figure~\ref{fig:foda:relations} shows all \FODA\ relationships and constraints.
% and Figure~\ref{section:introduction:figure:examples}
% shows some examples of how
% \FODA\ diagrams are built.
Although this kind of solutions is useful to easily model \SPLs, a formal approach is needed for automatizing the analysis process and detecting errors in the early stages of the production process. It is therefore required that graphical representations are translated into mathematical entities~\cite{nak10}. In this case, the original graphical representation of \FODA\ must be provided with a formal semantics~\cite{bhst04}.
%
This  issue is solved by using \fodaPA~\cite{acl13}, a formal framework to represent \FODA\ diagrams using process algebras. \fodaPA\ can be applied not only to \FODA, but also to represent other feature-related problems and variability models. Additionally, some of the existing formal approaches use algebras and semantics~\cite{szw05,kkm06,prb11,acl13}, while others use either propositional or first order logic~\cite{man02,ka07,abgf10,atfg10,nnz14}.

\begin{figure}[t]

\linefigure

\centering


\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm, semithick]

  \node[rectangle,draw] (A)   {\feature{A}};
  \node[rectangle,draw] (B) [below of=A]   {\feature{B}};

  \node[rectangle,draw] (C) [right of=A]   {\feature{A}};
  \node[rectangle,draw] (D) [below of=C]   {\feature{B}};

%  \node[] (E) [right of=C]   {};
  \node[rectangle,draw,node distance=4cm] (G) [right of=C]   {\feature{A}};
  \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%  \node[] (H) [below of=G]   {};
  \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};



  \path (A) edge [-o,shorten >=-0.05em] node[draw=none] {Optional} (B.north)
        (C) edge [-*,shorten >=-0.05em] node[draw=none] {Mandatory} (D.north)

        (G) edge [->]  node[draw=none, shift={(80:-0.5)}]{Choose-one} (F)
            edge [->]  node[draw=none] {} (I)  ;


\draw [<-] (6.8,-0.2) arc (-36:-140:20pt);

  \node[rectangle,draw,node distance=2.5cm] (J) [right of=G]   {\feature{A}};
  \node[rectangle,draw] (K) [below of=J]   {\feature{B}};

  \node[rectangle,draw] (L) [right of=J]   {\feature{A}};
  \node[rectangle,draw] (M) [below of=L]   {\feature{B}};


  \path
        (J) edge [->,dashed] node[draw=none] {Excludes} (K)
        (L) edge [->,dotted] node[draw=none] {Implies} (M)  ;

\end{tikzpicture}

\linefigure

\caption{\FODA\ Diagram representation.\label{fig:foda:relations}}

\end{figure}


% \begin{figure}[t]
% \linefigure
% \centering
% \begin{minipage}{0.2\hsize}
%         \centering
%         \EX{a}


%         \centering
%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]

%           \node[rectangle,draw] (A)   {\feature{A}};
%           \node[rectangle,draw,node distance=1.1cm] (B) [below of=A]   {\feature{B}};

%           \path (A) edge [-o] node[draw=none] {} (B.north)
%           ;
%         \end{tikzpicture}

% \end{minipage}
% %
% \begin{minipage}{0.1\hsize}

%         \centering

%         \EX{b}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (C) [right of=A]   {\feature{A}};
%           \node[rectangle,draw,node distance=1.1cm] (D) [below of=C]   {\feature{B}};
%           \path (C) edge [] node[draw=none] {} (D)
%           ;
%         \fill (D.north) circle (0.1);
%         \end{tikzpicture}

% \end{minipage}
% %
% \begin{minipage}{0.33\hsize}
% \centering

%         \EX{c}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (G)    {\feature{A}};
%           \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%           \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};

%           \path
%                 (G) edge [->]  node[draw=none] {} (F)
%                     edge [->]  node[draw=none] {} (I)

%           ;

%         \draw [<-] (0.7,-0.1) arc (360:180:14pt);

%         \end{tikzpicture}
% \end{minipage}
% \begin{minipage}{0.33\hsize}
% \centering

%         \EX{d}


%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
%           \node[rectangle,draw] (G)   {\feature{A}};

%           \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%           \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};
%           \path
%                 (G) edge []  node[draw=none] {} (F.north)
%                     edge []  node[draw=none] {} (I.north)
%           ;
%         \fill (F.north) circle (0.1);
%         \fill (I.north) circle (0.1);
%         \end{tikzpicture}
% \end{minipage}


% \linefigure



% \begin{minipage}{0.33\hsize}
% \centering
%         \EX{e}
% \vspace*{0.3em}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
%           \node[rectangle,draw] (G)    {\feature{A}};
%           \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%           \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};
%           \path
%                 (G) edge [-o]  node[draw=none] {} (F.north)
%                     edge []  node[draw=none] {} (I.north) ;
%         \fill (I.north) circle (0.1);
%         \end{tikzpicture}
% \end{minipage}
% \begin{minipage}{0.3\hsize}
%         \centering
%  \EX{f}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (A)    {\feature{A}};
%           \node[rectangle,draw] (B) [below left   of=A]   {\feature{B}};
%           \node[rectangle,draw] (C) [below right  of=A]   {\feature{C}};

%           \path
%                 (A) edge [-o]  node[draw=none] {} (B.north)
%                         edge [-o]  node[draw=none] {} (C.north)

%     (B) edge [->,dashed] node[draw=none] {} (C);
%         \end{tikzpicture}
% \end{minipage}
% \begin{minipage}{0.3\hsize}
%         \centering
%  \EX{g}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (A)    {\feature{A}};
%           \node[rectangle,draw] (B) [below left   of=A]   {\feature{B}};
%           \node[rectangle,draw] (C) [below right  of=A]   {\feature{C}};

%           \path
%                 (A) edge [-o]  node[draw=none] {} (B.north)
%                         edge [-o]  node[draw=none] {} (C.north)

%         (B) edge [->,dotted] node[draw=none] {} (C)
% ;
%         \end{tikzpicture}
% \end{minipage}
% \linefigure

% \caption{Examples of \FODA\ Diagrams.\label{section:introduction:figure:examples}}
% \end{figure}

%Feature Oriented Domain Analysis~\cite{kchnp90} (in short, \FODA) is a graphical
%representation of commonality and variability of systems. Figure~\ref{fig:foda:relations}
%shows all \FODA\ relationships and constraints.
%% and Figure~\ref{section:introduction:figure:examples}
%% shows some examples of how
%% \FODA\ diagrams are built.
%In order to perform automatic analysis,  graphical representations
%must be transformed into mathematical entities~\cite{nak10}.
%Thus, it is necessary to provide the original
%\FODA\ graphical representation with formal semantics base, where automated analysis can be
%performed~\cite{bhst04}. This  issue is solved by using \fodaPA~\cite{acl13}, a formal
%framework to represent \FODA\ diagrams using process algebras. \fodaPA\
%can only be applied not only to
%\FODA, but also to represent other feature-related
%problems and variability models.

%Costs within our formal framework refer to the required effort to add a feature to a product
%under construction. This cost refers to many factors depending on the context of the
%product line organization. For example, the cost of adding a feature to a product can be
%equal to the number of lines of code of a software component~\cite{n07,babc09}, or the
%effort, in terms of human hours, to develop that module. This effort is usually measured by using
%functional metrics~\cite{j04,cg08,hko13}. The cost of adding third-party modules, both
%commercial and open source, to our \SPL\ could be the time associated with integrating it into
%the product line organization.

%The order in which features are computed is important in many software projects and
%has an  important relevance to the final cost of the project. This order can be easily incorporated
%into the operational semantics of~\fodaPA. In this paper we represent costs with
%natural numbers. This is not a drawback of our formalism because we can assume a
%minimum cost unit, and therefore, any cost can be represented as a multiple of this unit.

It is worth to mention that the order in which features are processed to create a specific product is directly reflected in its final cost. In a previous work we introduced costs in our formal framework for representing the required effort to include a feature to the product under construction~\cite{clc16}. This cost may represent different aspects of a feature, such as lines of code of a given software component or effort, in human hours, to include a software component into a project, just to name a few, that usually depend on the target of the product line organization. Thus, efficiently processing features for building high quality products becomes a time-consuming and challenging task. Unfortunately, there are some situations where the representation of the \SPL\ generates a combinatorial explosion, making unpractical to analyze all possible combinations.
%
In order to alleviate this issue, in this paper we propose a probabilistic extension of our previous work \fodaPA. We use probabilistic information to identify those features that are more frequently used by computing the probability of having a feature in a specific \SPL. Hence, the computation focuses on those features with a high probability to be present in the final product, reducing the total computation required for generating valid products.
The proposed probabilistic extension is tested through a Python implementation.
In order to show its usefulness, we have conducted an experimental study where different
models consisting of 3000 features have been analyzed.
In this case, 247 features have a probability equal to 0.9 to be included in a final product. This means that, at least, the 90\% of the generated products have these 247 features, now,
doing a partial testing coverage over these feature we will reach an overall 90\% of the products in the partial coverage.

The main contributions of this work can be summarized as:

\begin{itemize}

        \item
        A model that uses probabilistic information to determine the probability of having a feature in a specific \SPL. In contrast with our previous work~\cite{acl13,clc16}, which mainly focuses in defining an algebraic language to describe Software Product Lines and using a cost model for comparing valid products, this approach is targeted to identify those features that are more frequently used to generate a product. Basically, the idea is to focus on those features with a high probability to be present in the final product and, therefore, reducing the required processing to generate valid products.

      \item It may be not feasible to compute all the products in a
        SPL. But if we are interested in a particular feature, we can
        compute the probability of that feature.  The introduction of
        the notion of hiding sets of features helps us to achieve
        this. If we want to compute the probability of \fA, we hide
        the features that do not affect the processing of \fA\ for
        being part of a valid product.  This analysis allows
        optimizing the practical application of the probabilistic
        extension, as it allows us to remove or hide a set of features
        which does not interfere with the calculus of the probability
        for a specific feature.

        \item
        A thorough empirical study, using different configurations to generate a wide-spectrum of variability models. The  study has been carried out in order to show the applicability and scalability of our approach. These variability models have been generated using BeTTy~\cite{sg12}.

        \item
        A comparison between the overall implementation performance of the probabilistic extension and the denotational semantic implementation from \fodaPA~\cite{acl13}. The obtained results show that the denotational semantics of the probabilistic extension implementation behaves more efficiently both in space and time
        in comparison with the denotational semantics implementations presented in previous work.

\end{itemize}


The rest of the paper is structured as follows.
Section \ref{ref:related_work} introduces the related work on probabilistic analysis
of feature models.
%Section \ref{sec:stat:sintaxMain} presents an introduction to the
%\fodaPA\ syntax and the main operators usage for both the operational and denotational semantics.
Section \ref{sec:stat:sintaxMain} presents our probabilistic language \fodaPAp.
Section \ref{sec:equivalenceMain} is used to prove the equivalence between the operational and denotational semantics.
In section \ref{sec:stat:hidMain} we extend our language to define how sets of features can be hidden. This new
hidden operator allows to improve the execution of the probabilistic
extension execution, as it allows to remove those features that are not required to calculate the probability.
Section~\ref{sec:stat:impl} presents an empirical study that has been carried out by using our implementation of the denotational semantics for the probabilistic extension.
Finally, section~\ref{section:jstat:concs} presents our conclusions and some research lines for the upcoming work.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%%   ispell-local-dictionary: "american"
%%% End:



% LocalWords:  formalisms
