% $Id: introduction.tex,v 1.8 2013/12/03 09:17:27 ccamacho Exp $
\section{Introduction}
\label{ref:introduction}

%The main purpose of Software Product Lines (in short, \SPLs) is to produce products
%while increasing productivity and shortening the time-to-market period. \SPLs\ depend
%on which software products are being produced and which of them are better for
%a specific criterion. When products are represented in a product line organization,
%several modeling approaches can be used to increase both quality and productivity.
%In most cases this is represented in the form of features, relationships and
%constraints. For instance, some of these approaches are FODA~\cite{kchnp90},
%RSEB~\cite{mj98} and PLUSS~\cite{k05,ebb06}.

During the last years, software product lines (in short, \SPLs) have become a widely adopted mechanism for efficient software development. The Carnegie Mellon Software Engineering Institute defines an \SPL\ as ``a set of software-intensive systems that share a common, managed set of features satisfying the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way''~\cite{mcg01}. Basically, the main goal of \SPLs\ is to increase the productivity for creating software products, which is achieved by selecting those software systems that are better for a specific criterion (e.g. a software system is less expensive than others, it requires less time to be processed, etc.). Currently, different approaches for representing the product line organization can be found in the literature, such as FODA~\cite{kchnp90},
RSEB~\cite{mj98} and PLUSS~\cite{k05,ebb06}.

Graphical approaches are commonly used to model \SPLs. Feature Oriented Domain Analysis~\cite{kchnp90} (in short, \FODA) is a well-known graphical approach for representing commonality and variability of systems. Figure~\ref{fig:foda:relations} shows all \FODA\ relationships and constraints.
% and Figure~\ref{section:introduction:figure:examples}
% shows some examples of how
% \FODA\ diagrams are built.
Although this kind of solutions is useful to easily model \SPLs, a formal approach is needed for automatizing the analysis process and detecting errors in the early stages of the production process. It is therefore required that graphical representations are translated into mathematical entities~\cite{nak10}. In this case, the original graphical representation of \FODA\ must be provided with a formal semantics~\cite{bhst04}.
%
This  issue is solved by using \fodaPA~\cite{acl13}, a formal framework to represent \FODA\ diagrams using process algebras. \fodaPA\ can be applied not only to \FODA, but also to represent other feature-related problems and variability models. Additionally, some of the existing formal approaches use algebras and semantics~\cite{szw05,kkm06,prb11,acl13}, while others use either propositional or first order logic~\cite{man02,ka07,abgf10,atfg10,nnz14}.

\begin{figure}[t]

\linefigure

\centering


\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm, semithick]

  \node[rectangle,draw] (A)   {\feature{A}};
  \node[rectangle,draw] (B) [below of=A]   {\feature{B}};

  \node[rectangle,draw] (C) [right of=A]   {\feature{A}};
  \node[rectangle,draw] (D) [below of=C]   {\feature{B}};

%  \node[] (E) [right of=C]   {};
  \node[rectangle,draw,node distance=4cm] (G) [right of=C]   {\feature{A}};
  \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%  \node[] (H) [below of=G]   {};
  \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};



  \path (A) edge [-o,shorten >=-0.05em] node[draw=none] {Optional} (B.north)
        (C) edge [-*,shorten >=-0.05em] node[draw=none] {Mandatory} (D.north)

        (G) edge [->]  node[draw=none, shift={(80:-0.5)}]{Choose-one} (F)
            edge [->]  node[draw=none] {} (I)  ;


\draw [<-] (6.8,-0.2) arc (-36:-140:20pt);

  \node[rectangle,draw,node distance=2.5cm] (J) [right of=G]   {\feature{A}};
  \node[rectangle,draw] (K) [below of=J]   {\feature{B}};

  \node[rectangle,draw] (L) [right of=J]   {\feature{A}};
  \node[rectangle,draw] (M) [below of=L]   {\feature{B}};


  \path
        (J) edge [->,dashed] node[draw=none] {Excludes} (K)
        (L) edge [->,dotted] node[draw=none] {Implies} (M)  ;

\end{tikzpicture}

\linefigure

\caption{\FODA\ Diagram representation.\label{fig:foda:relations}}

\end{figure}


% \begin{figure}[t]
% \linefigure
% \centering
% \begin{minipage}{0.2\hsize}
%         \centering
%         \EX{a}


%         \centering
%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]

%           \node[rectangle,draw] (A)   {\feature{A}};
%           \node[rectangle,draw,node distance=1.1cm] (B) [below of=A]   {\feature{B}};

%           \path (A) edge [-o] node[draw=none] {} (B.north)
%           ;
%         \end{tikzpicture}

% \end{minipage}
% %
% \begin{minipage}{0.1\hsize}

%         \centering

%         \EX{b}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (C) [right of=A]   {\feature{A}};
%           \node[rectangle,draw,node distance=1.1cm] (D) [below of=C]   {\feature{B}};
%           \path (C) edge [] node[draw=none] {} (D)
%           ;
%         \fill (D.north) circle (0.1);
%         \end{tikzpicture}

% \end{minipage}
% %
% \begin{minipage}{0.33\hsize}
% \centering

%         \EX{c}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (G)    {\feature{A}};
%           \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%           \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};

%           \path
%                 (G) edge [->]  node[draw=none] {} (F)
%                     edge [->]  node[draw=none] {} (I)

%           ;

%         \draw [<-] (0.7,-0.1) arc (360:180:14pt);

%         \end{tikzpicture}
% \end{minipage}
% \begin{minipage}{0.33\hsize}
% \centering

%         \EX{d}


%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
%           \node[rectangle,draw] (G)   {\feature{A}};

%           \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%           \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};
%           \path
%                 (G) edge []  node[draw=none] {} (F.north)
%                     edge []  node[draw=none] {} (I.north)
%           ;
%         \fill (F.north) circle (0.1);
%         \fill (I.north) circle (0.1);
%         \end{tikzpicture}
% \end{minipage}


% \linefigure



% \begin{minipage}{0.33\hsize}
% \centering
%         \EX{e}
% \vspace*{0.3em}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
%           \node[rectangle,draw] (G)    {\feature{A}};
%           \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%           \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};
%           \path
%                 (G) edge [-o]  node[draw=none] {} (F.north)
%                     edge []  node[draw=none] {} (I.north) ;
%         \fill (I.north) circle (0.1);
%         \end{tikzpicture}
% \end{minipage}
% \begin{minipage}{0.3\hsize}
%         \centering
%  \EX{f}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (A)    {\feature{A}};
%           \node[rectangle,draw] (B) [below left   of=A]   {\feature{B}};
%           \node[rectangle,draw] (C) [below right  of=A]   {\feature{C}};

%           \path
%                 (A) edge [-o]  node[draw=none] {} (B.north)
%                         edge [-o]  node[draw=none] {} (C.north)

%     (B) edge [->,dashed] node[draw=none] {} (C);
%         \end{tikzpicture}
% \end{minipage}
% \begin{minipage}{0.3\hsize}
%         \centering
%  \EX{g}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (A)    {\feature{A}};
%           \node[rectangle,draw] (B) [below left   of=A]   {\feature{B}};
%           \node[rectangle,draw] (C) [below right  of=A]   {\feature{C}};

%           \path
%                 (A) edge [-o]  node[draw=none] {} (B.north)
%                         edge [-o]  node[draw=none] {} (C.north)

%         (B) edge [->,dotted] node[draw=none] {} (C)
% ;
%         \end{tikzpicture}
% \end{minipage}
% \linefigure

% \caption{Examples of \FODA\ Diagrams.\label{section:introduction:figure:examples}}
% \end{figure}

%Feature Oriented Domain Analysis~\cite{kchnp90} (in short, \FODA) is a graphical
%representation of commonality and variability of systems. Figure~\ref{fig:foda:relations}
%shows all \FODA\ relationships and constraints.
%% and Figure~\ref{section:introduction:figure:examples}
%% shows some examples of how
%% \FODA\ diagrams are built.
%In order to perform automatic analysis,  graphical representations
%must be transformed into mathematical entities~\cite{nak10}.
%Thus, it is necessary to provide the original
%\FODA\ graphical representation with formal semantics base, where automated analysis can be
%performed~\cite{bhst04}. This  issue is solved by using \fodaPA~\cite{acl13}, a formal
%framework to represent \FODA\ diagrams using process algebras. \fodaPA\
%can only be applied not only to
%\FODA, but also to represent other feature-related
%problems and variability models.

%Costs within our formal framework refer to the required effort to add a feature to a product
%under construction. This cost refers to many factors depending on the context of the
%product line organization. For example, the cost of adding a feature to a product can be
%equal to the number of lines of code of a software component~\cite{n07,babc09}, or the
%effort, in terms of human hours, to develop that module. This effort is usually measured by using
%functional metrics~\cite{j04,cg08,hko13}. The cost of adding third-party modules, both
%commercial and open source, to our \SPL\ could be the time associated with integrating it into
%the product line organization.

%The order in which features are computed is important in many software projects and
%has an  important relevance to the final cost of the project. This order can be easily incorporated
%into the operational semantics of~\fodaPA. In this paper we represent costs with
%natural numbers. This is not a drawback of our formalism because we can assume a
%minimum cost unit, and therefore, any cost can be represented as a multiple of this unit.

It is worth to mention that the order in which features are processed to create a specific product is directly reflected in its final cost. In a previous work we introduced costs in our formal framework for representing the required effort to include a feature to the product under construction~\cite{cln16}. This cost may represent different aspects of a feature, such us lines of code of a given software component or effort, in human hours, to include a software component into a project, just to name a few, that usually depend on the target of the product line organization. Thus, efficiently processing features for building high quality products becomes a time-consuming and challenging task. Unfortunately, there are some situations where the representation of the \SPL\ generates a combinatorial explosion, making unpractical to analyze all possible combinations.
%
In order to alleviate this issue, in this paper we propose a probabilistic extension of our previous work \fodaPA. We use probabilistic information to identify those features that are more frequently used by computing the probability of having a feature in a specific \SPL. Hence, the computation focuses on those features with a high probability to be present in the final product, reducing the total computation required for generating valid products. The proposed probabilistic extension has been fully implemented in a tool. In order to show its usefulness, we have conducted an experimental study where different models consisting of 1500 features have been analyzed. The obtained results are promising. In this case, 450 features have a probability equal to 0.75 to be included in a final product. This means that, at least, the 75\% of the generated products are tested by only analyzing the 30\% of the features in the \SPL\ (450 features).

The study of probabilistic extensions of formal methods can be dated back to the end of the 1980s. This is already a well established area, with many extensive contributions to include probabilistic information in classical formalisms (I/O Automata, Finite State Machines, (co-)algebraic approaches, among others)~\cite{ls91,rgs95,cdsy99,nun03,lnr06,csv07,dp07,dghm08,hm09,aprs11,sok11,hn12,dghm14,agl16}.
%
%
%Figures like the displayed trees describe how probabilities are assigned in the system behavior (see Figure~\ref{fig:displayedTrees}). These models allow to assign a real value between 0 and 1 to each transition in order to execute an event. It is important to notice that the probability of execute a transition \textit{t} is not necessarily equal to the other probabilities from the same level.
%\begin{figure}[h]
%	\hspace{50px}
%	\begin{minipage}{0.4\hsize}       		
%		
%		\begin{minipage}{0.2\hsize}
%			\scalebox{0.6}{
%				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm, semithick]
%				
%				\node[circle,draw] (A)   {};
%				\node[circle,draw] (B) [below left of=A]   {};
%				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (F) [below of=B]   {T};
%				\node[circle,draw] (C) [below right of=A]   {};
%				\node[circle,draw] (D) [below left of=C]   {};
%				\node[circle,draw] (E) [below right of=C]   {};
%				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (G) [below  of=D]   {T};
%				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (H) [below  of=E]   {T};			 
%				
%				\path (A) edge [] node [pos=0.5, above left, draw=white, opacity=0, text opacity=1]{1/3} (B);
%				\path (B) edge [] node [pos=0.5, left, draw=white, opacity=0, text opacity=1]{a} (F);
%				\path (A) edge [] node [pos=0.5, above right, draw=white, opacity=0, text opacity=1]{1/2} (C);
%				\path (C) edge [] node [pos=0.5, above left, draw=white, opacity=0, text opacity=1]{1/2} (D);
%				\path (C) edge [] node [pos=0.5, above right, draw=white, opacity=0, text opacity=1]{1/2} (E);
%				\path (D) edge [] node [pos=0.5, right, draw=white, opacity=0, text opacity=1]{b} (G);
%				\path (E) edge [] node [pos=0.5, left, draw=white, opacity=0, text opacity=1]{c} (H);
%				\end{tikzpicture}
%			}
%		\end{minipage}
%	\end{minipage}
%	\begin{minipage}{0.4\hsize}
%		
%		\begin{minipage}{0.2\hsize}
%			\scalebox{0.6}{
%				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]
%				\node[circle,draw] (A)   {};
%				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (B) [below left of=A]   {T};
%				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (C) [below  of=A]   {T};			 
%				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (D) [below right of=A]   {T};			 
%				
%				\path (A) edge [] node [pos=0.5, above left, draw=white, opacity=0, text opacity=1]{1/3} (B);
%				\path (A) edge [] node [pos=0.5, left, draw=white, opacity=0, text opacity=1]{1/3} (C);
%				\path (A) edge [] node [pos=0.5, above right, draw=white, opacity=0, text opacity=1]{1/3} (D);
%				
%				\end{tikzpicture}}
%		\end{minipage}
%		
%	\end{minipage}
%	
%	\caption{Displayed trees representing probabilities.}
%	\label{fig:displayedTrees}
%	
%\end{figure}
%
%\acomen{He puesto t√≠tulo y referencia a esta figura (Fig. 2). Please, check!}
%
%\acomen{Carlos, he cambiado el siguiente texto con referencias a papers de probabilidades. Please, check para ver que no digo nada cantoso)}
%%
Although the addition of probabilistic information to model \SPLs\ is relatively new, there are already several proposals in the literature~\cite{chssgl13,tllv15,tlll15,dpcslsh17}. In particular, very recent 
work~\cite{dpcslsh17} shows that statistic analysis allows users to determine relevant characteristics, like the certainty of finding valid products among complex models.
%
Another approach~\cite{chssgl13} focuses on testing properties of \SPLs, like reliability, by defining three verification techniques: a probabilistic model checker on each product, on a model range, and testing the behavior relations with other models.
%
Some of these approaches describe models to run statistical analysis over \SPLs, where pre-defined syntactic elements are computed by applying a specific set of operational rules~\cite{tllv15,tlll15}. These models demonstrate their ability to be integrated into standard tools like QFLan, Microsoft's SMT Z3 and MultiVeStA.
%
%Some of these works describe models to run statistical analysis to represent \SPLs\ by defining an specific set of operational rules to compute their defined syntax elements~\cite{tllv15,tlll15}. These models demonstrate their ability by being integrated to standard tools like QFLan, Microsoft's SMT Z3 and MultiVeStA.
%
%Other works focus on describing use cases for analyzing the probability of finding features inside valid products~\cite{dpcslsh17}. %An interesting feature is that any of the referenced research articles describe their approaches using multisets.

The main contributions of this work can be summarized as:

\begin{itemize}

	\item 
	
	A model that uses probabilistic information to determine the probability of having a feature in a specific \SPL. In contrast with our previous work~\cite{acl13,clc16}, which mainly focuses in defining an algebraic language to describe Software Product Lines and using a cost model for comparing valid products, this approach is targeted to identify those features that are more frequently used to generate a product. Basically, the idea is to focus on those features with a high probability to be present in the final product and, therefore, reducing the required processing to generate valid products. 
		
	\item  A thorough empirical study, using different configurations to generate a wide-spectrum of variability models. The  study has been carried out in order to show the applicability and scalability of our approach. These variability models have been generated using BeTTy~\cite{SeguraHBC11}.
	
	\item A complete comparison between the overall implementation performance of the probabilistic extension and the denotational semantic implementation from \fodaPA~\cite{acl13}. The obtained results show that the denotational semantics of the probabilistic extension implementation dramatically improves the performance
in comparison with the denotational semantics implementations presented in previous work.

\end{itemize}


The rest of the paper is structured as follows. Section \ref{sec:stat:sintaxMain} presents our language. Section \ref{sec:equivalenceMain} is used to prove the equivalence between the operational and denotational semantics. In section \ref{sec:stat:hidMain} we extend our language to define how sets of features can be hidden. Section~\ref{sec:stat:impl} presents an empirical study that has been carried out by using our implementation of the denotational semantics for the probabilistic extension. Finally, section~\ref{section:jstat:concs} presents our conclusions and some lnes of future work.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%%   ispell-local-dictionary: "american"
%%% End:



% LocalWords:  formalisms
