% $Id: introduction.tex,v 1.8 2013/12/03 09:17:27 ccamacho Exp $
\section{Introduction}
\label{ref:introduction}

%The main purpose of Software Product Lines (in short, \SPLs) is to produce products
%while increasing productivity and shortening the time-to-market period. \SPLs\ depend
%on which software products are being produced and which of them are better for
%a specific criterion. When products are represented in a product line organization,
%several modeling approaches can be used to increase both quality and productivity.
%In most cases this is represented in the form of features, relationships and
%constraints. For instance, some of these approaches are FODA~\cite{kchnp90},
%RSEB~\cite{mj98} and PLUSS~\cite{k05,ebb06}.

During the last years, software product lines (in short, \SPLs) have become a widely adopted mechanism for efficient software development. Carnegie Mellon Software Engineering Institute defines a \SPL\ as ``a set of software-intensive systems that share a common, managed set of features satisfying the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way''. Basically, the main goal of \SPLs\ is to increase the productivity for creating software products, which is achieved by selecting those software systems that are better for a specific criterion (e.g. a software system is less expensive than others, it requires less time to be processed, etc.). Currently, different approaches for representing the product line organization can be found in the literature, such as FODA~\cite{kchnp90},
RSEB~\cite{mj98} and PLUSS~\cite{k05,ebb06}.

Graphical approaches are commonly used to model \SPLs. Feature Oriented Domain Analysis~\cite{kchnp90} (in short, \FODA) is a well-known graphical approach for representing commonality and variability of systems. Fig.~\ref{fig:foda:relations} shows all \FODA\ relationships and constraints.
% and Figure~\ref{section:introduction:figure:examples}
% shows some examples of how
% \FODA\ diagrams are built.
Although this kind of solutions is useful to easily model \SPLs, a formal approach is needed for automatizing the analysis process and detecting errors in the early stages of the production process. It is therefore required that graphical representations are translated into mathematical entities~\cite{nak10}. In this case, the original graphical representation of \FODA\ must be provided with formal semantics base~\cite{bhst04}.
%
This  issue is solved by using \fodaPA~\cite{acl13}, a formal framework to represent \FODA\ diagrams using process algebras. \fodaPA\ can be applied not only to \FODA, but also to represent other feature-related problems and variability models. Additionally, some of the existing formal approaches use algebras and semantics~\cite{szw05,kkm06,prb11,acl13}, while others use propositional or first order logic~\cite{man02,ka07,abgf10,atfg10,nnz14}.

\begin{figure}[t]

\linefigure

\centering


\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm, semithick]

  \node[rectangle,draw] (A)   {\feature{A}};
  \node[rectangle,draw] (B) [below of=A]   {\feature{B}};

  \node[rectangle,draw] (C) [right of=A]   {\feature{A}};
  \node[rectangle,draw] (D) [below of=C]   {\feature{B}};

%  \node[] (E) [right of=C]   {};
  \node[rectangle,draw,node distance=4cm] (G) [right of=C]   {\feature{A}};
  \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%  \node[] (H) [below of=G]   {};
  \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};



  \path (A) edge [-o,shorten >=-0.05em] node[draw=none] {Optional} (B.north)
        (C) edge [-*,shorten >=-0.05em] node[draw=none] {Mandatory} (D.north)

        (G) edge [->]  node[draw=none, shift={(80:-0.5)}]{Choose 1} (F)
            edge [->]  node[draw=none] {} (I)  ;


\draw [<-] (6.8,-0.2) arc (-36:-140:20pt);

  \node[rectangle,draw,node distance=2.5cm] (J) [right of=G]   {\feature{A}};
  \node[rectangle,draw] (K) [below of=J]   {\feature{B}};

  \node[rectangle,draw] (L) [right of=J]   {\feature{A}};
  \node[rectangle,draw] (M) [below of=L]   {\feature{B}};


  \path
        (J) edge [->,dashed] node[draw=none] {Excludes} (K)
        (L) edge [->,dotted] node[draw=none] {Implies} (M)  ;

\end{tikzpicture}

\linefigure

\caption{\FODA\ Diagram representation.\label{fig:foda:relations}}

\end{figure}


% \begin{figure}[t]
% \linefigure
% \centering
% \begin{minipage}{0.2\hsize}
%         \centering
%         \EX{a}


%         \centering
%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]

%           \node[rectangle,draw] (A)   {\feature{A}};
%           \node[rectangle,draw,node distance=1.1cm] (B) [below of=A]   {\feature{B}};

%           \path (A) edge [-o] node[draw=none] {} (B.north)
%           ;
%         \end{tikzpicture}

% \end{minipage}
% %
% \begin{minipage}{0.1\hsize}

%         \centering

%         \EX{b}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (C) [right of=A]   {\feature{A}};
%           \node[rectangle,draw,node distance=1.1cm] (D) [below of=C]   {\feature{B}};
%           \path (C) edge [] node[draw=none] {} (D)
%           ;
%         \fill (D.north) circle (0.1);
%         \end{tikzpicture}

% \end{minipage}
% %
% \begin{minipage}{0.33\hsize}
% \centering

%         \EX{c}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (G)    {\feature{A}};
%           \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%           \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};

%           \path
%                 (G) edge [->]  node[draw=none] {} (F)
%                     edge [->]  node[draw=none] {} (I)

%           ;

%         \draw [<-] (0.7,-0.1) arc (360:180:14pt);

%         \end{tikzpicture}
% \end{minipage}
% \begin{minipage}{0.33\hsize}
% \centering

%         \EX{d}


%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
%           \node[rectangle,draw] (G)   {\feature{A}};

%           \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%           \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};
%           \path
%                 (G) edge []  node[draw=none] {} (F.north)
%                     edge []  node[draw=none] {} (I.north)
%           ;
%         \fill (F.north) circle (0.1);
%         \fill (I.north) circle (0.1);
%         \end{tikzpicture}
% \end{minipage}


% \linefigure



% \begin{minipage}{0.33\hsize}
% \centering
%         \EX{e}
% \vspace*{0.3em}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
%           \node[rectangle,draw] (G)    {\feature{A}};
%           \node[rectangle,draw] (F) [below left of=G]   {\feature{B}};
%           \node[rectangle,draw] (I) [below right  of=G]   {\feature{C}};
%           \path
%                 (G) edge [-o]  node[draw=none] {} (F.north)
%                     edge []  node[draw=none] {} (I.north) ;
%         \fill (I.north) circle (0.1);
%         \end{tikzpicture}
% \end{minipage}
% \begin{minipage}{0.3\hsize}
%         \centering
%  \EX{f}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (A)    {\feature{A}};
%           \node[rectangle,draw] (B) [below left   of=A]   {\feature{B}};
%           \node[rectangle,draw] (C) [below right  of=A]   {\feature{C}};

%           \path
%                 (A) edge [-o]  node[draw=none] {} (B.north)
%                         edge [-o]  node[draw=none] {} (C.north)

%     (B) edge [->,dashed] node[draw=none] {} (C);
%         \end{tikzpicture}
% \end{minipage}
% \begin{minipage}{0.3\hsize}
%         \centering
%  \EX{g}

%         \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]


%           \node[rectangle,draw] (A)    {\feature{A}};
%           \node[rectangle,draw] (B) [below left   of=A]   {\feature{B}};
%           \node[rectangle,draw] (C) [below right  of=A]   {\feature{C}};

%           \path
%                 (A) edge [-o]  node[draw=none] {} (B.north)
%                         edge [-o]  node[draw=none] {} (C.north)

%         (B) edge [->,dotted] node[draw=none] {} (C)
% ;
%         \end{tikzpicture}
% \end{minipage}
% \linefigure

% \caption{Examples of \FODA\ Diagrams.\label{section:introduction:figure:examples}}
% \end{figure}

%Feature Oriented Domain Analysis~\cite{kchnp90} (in short, \FODA) is a graphical
%representation of commonality and variability of systems. Figure~\ref{fig:foda:relations}
%shows all \FODA\ relationships and constraints.
%% and Figure~\ref{section:introduction:figure:examples}
%% shows some examples of how
%% \FODA\ diagrams are built.
%In order to perform automatic analysis,  graphical representations
%must be transformed into mathematical entities~\cite{nak10}.
%Thus, it is necessary to provide the original
%\FODA\ graphical representation with formal semantics base, where automated analysis can be
%performed~\cite{bhst04}. This  issue is solved by using \fodaPA~\cite{acl13}, a formal
%framework to represent \FODA\ diagrams using process algebras. \fodaPA\
%can only be applied not only to
%\FODA, but also to represent other feature-related
%problems and variability models.

%Costs within our formal framework refer to the required effort to add a feature to a product
%under construction. This cost refers to many factors depending on the context of the
%product line organization. For example, the cost of adding a feature to a product can be
%equal to the number of lines of code of a software component~\cite{n07,babc09}, or the
%effort, in terms of human hours, to develop that module. This effort is usually measured by using
%functional metrics~\cite{j04,cg08,hko13}. The cost of adding third-party modules, both
%commercial and open source, to our \SPL\ could be the time associated with integrating it into
%the product line organization.

%The order in which features are computed is important in many software projects and
%has an  important relevance to the final cost of the project. This order can be easily incorporated
%into the operational semantics of~\fodaPA. In this paper we represent costs with
%natural numbers. This is not a drawback of our formalism because we can assume a
%minimum cost unit, and therefore, any cost can be represented as a multiple of this unit.

It is worth to mention that the order in which features are processed to create a specific product is directly reflected in its final cost. In a previous work we introduced costs in our formal framework for representing the required effort to include a feature to the product under construction~\cite{cln16}. This cost may represent different aspects of a feature, such us lines of code of a given software component or effort, in human hours, to include a software component into a project, just to name a few, that usually depends on the target of the product line organization. Thus, efficiently processing features for building high quality products becomes a time-consuming and challenging task. Unfortunately, there are some situations where the representation of the \SPL\ generates a combinatorial explosion, making unpractical to analyze all possible combinations.

\acomen{Aquí introduzco probabilidades. Manuel, tu magia aquí! :)}

In order to alleviate this issue, we propose a probabilistic extension of our previous work \fodaPA. We use probabilistic information to identify those features that are more frequently used by computing the probability of having a feature in a specific \SPL. Hence, the computation is focused on those features with a high probability to be present in the final product, reducing the total computation required for generating valid products.

Formal methods and process algebras have evolved to extend their relations to support probabilistic models~\cite{pp01,l19911}. Figures like the displayed trees describe how probabilities are assigned in the system behavior (see Fig.~\ref{fig:displayedTrees}). These models allow to assign a real value between 0 and 1 to each transition in order to execute an event. It is important to notice that the probability of execute a transition \textit{t} is not necessarily equal to the other probabilities from the same level.
\begin{figure}[h]
	\hspace{50px}
	\begin{minipage}{0.4\hsize}       		
		
		\begin{minipage}{0.2\hsize}
			\scalebox{0.6}{
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm, semithick]
				
				\node[circle,draw] (A)   {};
				\node[circle,draw] (B) [below left of=A]   {};
				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (F) [below of=B]   {T};
				\node[circle,draw] (C) [below right of=A]   {};
				\node[circle,draw] (D) [below left of=C]   {};
				\node[circle,draw] (E) [below right of=C]   {};
				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (G) [below  of=D]   {T};
				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (H) [below  of=E]   {T};			 
				
				\path (A) edge [] node [pos=0.5, above left, draw=white, opacity=0, text opacity=1]{1/3} (B);
				\path (B) edge [] node [pos=0.5, left, draw=white, opacity=0, text opacity=1]{a} (F);
				\path (A) edge [] node [pos=0.5, above right, draw=white, opacity=0, text opacity=1]{1/2} (C);
				\path (C) edge [] node [pos=0.5, above left, draw=white, opacity=0, text opacity=1]{1/2} (D);
				\path (C) edge [] node [pos=0.5, above right, draw=white, opacity=0, text opacity=1]{1/2} (E);
				\path (D) edge [] node [pos=0.5, right, draw=white, opacity=0, text opacity=1]{b} (G);
				\path (E) edge [] node [pos=0.5, left, draw=white, opacity=0, text opacity=1]{c} (H);
				\end{tikzpicture}
			}
		\end{minipage}
	\end{minipage}
	\begin{minipage}{0.4\hsize}
		
		\begin{minipage}{0.2\hsize}
			\scalebox{0.6}{
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]
				\node[circle,draw] (A)   {};
				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (B) [below left of=A]   {T};
				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (C) [below  of=A]   {T};			 
				\node[regular polygon,regular polygon sides=3,draw,scale=0.8] (D) [below right of=A]   {T};			 
				
				\path (A) edge [] node [pos=0.5, above left, draw=white, opacity=0, text opacity=1]{1/3} (B);
				\path (A) edge [] node [pos=0.5, left, draw=white, opacity=0, text opacity=1]{1/3} (C);
				\path (A) edge [] node [pos=0.5, above right, draw=white, opacity=0, text opacity=1]{1/3} (D);
				
				\end{tikzpicture}}
		\end{minipage}
		
	\end{minipage}
	
	\caption{Displayed trees representing probabilities.}
	\label{fig:displayedTrees}
	
\end{figure}

\acomen{He puesto título y referencia a esta figura (Fig. 2). Please, check!}

\acomen{Carlos, he cambiado el siguiente texto con referencias a papers de probabilidades. Please, check para ver que no digo nada cantoso)}

Several works in the literature show that statistic analysis over \SPLs\ allow to determine relevant characteristics, like the certainty of finding valid products among complex models~\cite{tllv15,tlll15,chssgl13,dpcslsh17}.
%
Some of these works describe models to run statistical analysis over \SPLs, where pre-defined syntax elements are computed by applying a specific set of operational rules~\cite{tllv15,tlll15}. These models demonstrate their ability to be integrated into standard tools like QFLan, Microsoft's SMT Z3 and MultiVeStA.
%
%Some of these works describe models to run statistical analysis to represent \SPLs\ by defining an specific set of operational rules to compute their defined syntax elements~\cite{tllv15,tlll15}. These models demonstrate their ability by being integrated to standard tools like QFLan, Microsoft's SMT Z3 and MultiVeStA.
%
Cordy et al. focus on testing properties of \SPLs, like reliability, which defines three verification techniques, a probabilistic model checker on each product, on a model range, and testing the behavior relations with other models~\cite{chssgl13}. Other works focus on describing use cases for analyzing the probability of finding features inside valid products~\cite{dpcslsh17}. %An interesting feature is that any of the referenced research articles describe their approaches using multisets.

The rest of the paper is structured as follows. Section \ref{sec:stat:sintaxMain} presents our language. Section \ref{sec:equivalenceMain} describes the equivalence between the operational and denotational semantics. In section \ref{sec:stat:hidMain} we describe how the sets of features are hidden. Section~\ref{sec:stat:impl} shows our implementation of the denotational semantics for the probabilistic extension. Finally, section~\ref{section:jstat:concs} presents our conclusions and some future work.

\acomen{He cambiado el nombre de secciones (label) repetidas. Please, check!.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%%   ispell-local-dictionary: "american"
%%% End:



% LocalWords:  formalisms
