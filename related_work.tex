% $Id: introduction.tex,v 1.8 2013/12/03 09:17:27 ccamacho Exp $
\section{Related work}
\label{ref:related_work}

The study of probabilistic extensions of formal methods can be dated
back to the end of the 1980s. This is already a well established area,
with many extensive contributions to include probabilistic information
in classical formalisms (I/O Automata, Finite State Machines,
(co-)algebraic approaches, among 
others)~\cite{hm09,aprs11,sok11,hn12,dghm14,agl16,Dubslaff2015}.
%others)~\cite{ls91,rgs95,cdsy99,nun03,lnr06,csv07,dp07,dghm08,hm09,aprs11,sok11,hn12,dghm14,agl16,Dubslaff2015}.
%
%
%Figures like the displayed trees describe how probabilities are assigned in the system behavior (see Figure~\ref{fig:displayedTrees}). These models allow to assign a real value between 0 and 1 to each transition in order to execute an event. It is important to notice that the probability of execute a transition \textit{t} is not necessarily equal to the other probabilities from the same level.
%\begin{figure}[h]
%       \hspace{50px}
%       \begin{minipage}{0.4\hsize}
%
%               \begin{minipage}{0.2\hsize}
%                       \scalebox{0.6}{
%                               \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm, semithick]
%
%                               \node[circle,draw] (A)   {};
%                               \node[circle,draw] (B) [below left of=A]   {};
%                               \node[regular polygon,regular polygon sides=3,draw,scale=0.8] (F) [below of=B]   {T};
%                               \node[circle,draw] (C) [below right of=A]   {};
%                               \node[circle,draw] (D) [below left of=C]   {};
%                               \node[circle,draw] (E) [below right of=C]   {};
%                               \node[regular polygon,regular polygon sides=3,draw,scale=0.8] (G) [below  of=D]   {T};
%                               \node[regular polygon,regular polygon sides=3,draw,scale=0.8] (H) [below  of=E]   {T};
%
%                               \path (A) edge [] node [pos=0.5, above left, draw=white, opacity=0, text opacity=1]{1/3} (B);
%                               \path (B) edge [] node [pos=0.5, left, draw=white, opacity=0, text opacity=1]{a} (F);
%                               \path (A) edge [] node [pos=0.5, above right, draw=white, opacity=0, text opacity=1]{1/2} (C);
%                               \path (C) edge [] node [pos=0.5, above left, draw=white, opacity=0, text opacity=1]{1/2} (D);
%                               \path (C) edge [] node [pos=0.5, above right, draw=white, opacity=0, text opacity=1]{1/2} (E);
%                               \path (D) edge [] node [pos=0.5, right, draw=white, opacity=0, text opacity=1]{b} (G);
%                               \path (E) edge [] node [pos=0.5, left, draw=white, opacity=0, text opacity=1]{c} (H);
%                               \end{tikzpicture}
%                       }
%               \end{minipage}
%       \end{minipage}
%       \begin{minipage}{0.4\hsize}
%
%               \begin{minipage}{0.2\hsize}
%                       \scalebox{0.6}{
%                               \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]
%                               \node[circle,draw] (A)   {};
%                               \node[regular polygon,regular polygon sides=3,draw,scale=0.8] (B) [below left of=A]   {T};
%                               \node[regular polygon,regular polygon sides=3,draw,scale=0.8] (C) [below  of=A]   {T};
%                               \node[regular polygon,regular polygon sides=3,draw,scale=0.8] (D) [below right of=A]   {T};
%
%                               \path (A) edge [] node [pos=0.5, above left, draw=white, opacity=0, text opacity=1]{1/3} (B);
%                               \path (A) edge [] node [pos=0.5, left, draw=white, opacity=0, text opacity=1]{1/3} (C);
%                               \path (A) edge [] node [pos=0.5, above right, draw=white, opacity=0, text opacity=1]{1/3} (D);
%
%                               \end{tikzpicture}}
%               \end{minipage}
%
%       \end{minipage}
%
%       \caption{Displayed trees representing probabilities.}
%       \label{fig:displayedTrees}
%
%\end{figure}
%
%\acomen{He puesto t√≠tulo y referencia a esta figura (Fig. 2). Please, check!}
%
%\acomen{Carlos, he cambiado el siguiente texto con referencias a papers de probabilidades. Please, check para ver que no digo nada cantoso)}
%%
Although the addition of probabilistic information to model \SPLs\ is relatively new, different proposals can be found in the current literature~\cite{chssgl13,tllv15,tlll15,dpcslsh17}. In particular, a very recent
work shows that statistic analysis allows users to determine relevant characteristics, like the certainty of finding valid products among complex models~\cite{dpcslsh17}.
%
Another approach focuses on testing properties of \SPLs, like reliability, by defining three verification techniques: a probabilistic model checker on each product, on a model range, and testing the behavior relations with other models~\cite{chssgl13}.
%
Some of these approaches describe models to run statistical analysis over \SPLs, where pre-defined syntactic elements are computed by applying a specific set of operational rules~\cite{tllv15,tlll15}. These models demonstrate their ability to be integrated into standard tools, like QFLan~\cite{tlll15}, Microsoft's SMT Z3~\cite{ln08} and MultiVeStA~\cite{sa13}.
%
%Some of these works describe models to run statistical analysis to represent \SPLs\ by defining an specific set of operational rules to compute their defined syntax elements~\cite{tllv15,tlll15}. These models demonstrate their ability by being integrated to standard tools like QFLan, Microsoft's SMT Z3 and MultiVeStA.
%

Other works focus on describing use cases for analyzing the probability of finding features inside valid products~\cite{dpcslsh17}.
It is true that variability models computing can create combinatory problems
depending on how the models are computed and how the models are represented, which is directly
correlated to the information to be generated~\cite{dpcslsh17}.
This analysis makes the process of studying product lines a complex computational  task.

An interesting aspect of \fodaPAp is that
any of the research articles in the literature manage
to describe in their work the use of multisets.
Also, they do not explicitly work on
the translation of \FODA\ to represent probabilities and they do
not introduce the notion of hiding those not needed features to
calculate the probability of a specific feature.

In particular, there exist mathematical verification models that
allow the representation of the products - of a product line - using models,
like discrete time Markov chain families, for representing the probabilistic behavior of all
the products in the product line~\cite{vk13}. Their implementations do not
provide a literal translation between the existing variability models, like FODA,
and, therefore, these do not provide implementations over their practical uses.
However, these approaches present analysis techniques that should have
a significant impact on the effort to compute variability models.

In previous years, the studies focusing the analysis of variability models  - and
their practical applications - with realistic use cases 
have demonstrated that those uses cases do not describe such complex models~\cite{jhf11, jhfes12}. Thus, these
can be processed in the practice without much algorithmic sophistication or
complex analysis.
In particular, the study of expending machines
has been widely used across the whole
literature to show practical and real usages of products
line modeling~\cite{jhfes12}. Moreover, it is described that those models for defining products
lines does not always apply to the
formal definition and description of software
product lines, as they are not directly related~\cite{cds06, fub06, nnz14}.
Recent implementations, like ProFeat~\cite{Chrszon2018}, allow to 
help in the verification of requirements for families of probabilistic systems. These implementations,  
together with PRISM~\cite{mgd12}, use their own language and are based on Markov decision processes.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
